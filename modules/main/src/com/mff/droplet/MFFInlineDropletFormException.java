package com.mff.droplet;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import atg.naming.NameContext;
import atg.naming.NameContextElement;
import atg.servlet.SessionNameContext;

/**
 * This class is designed to give easy access to the Nucleus component and property path that was problematic in a form submit.  
 * The DropletFormException constructors expect to be passed a propertyPath, which it expects to be something like 
 * "/atg/userprofiling/ProfileFormHandler.login" and the getPropertyName() method then extracts the property name from this.  
 * 
 * This is an improvement to that design as a) nobody wants to type that much b) it precludes setting up multiple Nucleus components 
 * for the same class i.e. you have to know the Nucleus path at compile time or do something clever. In practice people tend to pass 
 * the propertyName as the propertyPath just because it is a required field on the constructor.  Also providing the exceptionSource
 * property which is a reference to the component that created the exception, and the getFullPropertyPath method that resolves the 
 * full component path and uses it to determine the final value.
 * 
 * @author jureth@Knowledgepath
 *  
 */
public class MFFInlineDropletFormException extends MFFDropletFormException {

	//------------------------------------------
	// PRIVATE VARIABLES
	// ------------------------------------------
	private static final long serialVersionUID = 14566894389L;
	
	private NameContextElement mExceptionSource;
	
	// This is populated when a form name was explicitly specified, rather than
	// using the autogenerated value based on bean
	// Key is the autogenerated value, and value is the developer override
	private Map<String,String> mExplicitFormElementNames = new HashMap<String,String>();
	
	// Set of property names/fields that this exception applies to.  For example ['email'] or ['password','confirmPassword']
	private Set<String> mPropertyNames = new HashSet<String>();
	private String mFormId;
	
	//------------------------------------------
	// PUBLIC METHODS
	// ------------------------------------------
	public String toString() {
		
		StringBuilder builder = new StringBuilder();
		builder.append("formId: ").append(getFormId()).append("; formElementNames: ");
		builder.append(getFormElementNamesConcat()).append("; message: ");
		builder.append(getMessage()).append("; ");
		
		return builder.toString();
	}
	
	/**
	 * Returns the set of all form element names for which the exception occurred.  These can either be
	 * autogenerated (component + property name) or can be explicit names specified by the page
	 * developer in the JSP.
	 * 
	 * @return
	 */
	public Set<String> getFormElementNames() {
		Set<String> formElNames = new HashSet<String>();
		
		for (String propName : getPropertyNames()) {
			formElNames.add(propName);
		}
		
		return formElNames;
	}
	
	public String getFormElementNamesConcat() {
		StringBuilder builder = new StringBuilder();
		
		Set<String> names = getFormElementNames();
		Iterator<String> iter = names.iterator();
		while (iter.hasNext()) {
			builder.append(iter.next());
			if (iter.hasNext()) {
				builder.append(',');
			}
		}
		
		return builder.toString();
	}
	
	public Set<String> getFullPropertyPaths() {		
		Set<String> paths = new HashSet<String>();
		if (getPropertyNames() == null) {
		    	return paths;
		}
		
		
		for (String propName : getPropertyNames()) {
			String fullPath = getFullPropertyPath(propName);
			if (fullPath != null) {
				paths.add(fullPath);
			}
		}
		
		return paths;
	}
	
	

	/**
	 * @param pStr
	 * @param pPropertyName
	 */
	public MFFInlineDropletFormException(String pStr, String pPropertyName) {
		super(pStr, pPropertyName);
		getPropertyNames().add(pPropertyName);
	}
	
	public MFFInlineDropletFormException(String msg, Collection<String> pPropertyNames) {
		this(msg, (pPropertyNames == null 
				|| pPropertyNames.isEmpty() ? "" : pPropertyNames.iterator().next()));
		if (pPropertyNames != null) {
			getPropertyNames().addAll(pPropertyNames);
		}
	}
	
	/**
	 * @param pStr
	 * @param pPropertyName
	 */
	public MFFInlineDropletFormException(String pStr, String pPropertyName, NameContextElement pExceptionSource) {
		this(pStr, pPropertyName);
		mExceptionSource = pExceptionSource;
	}
	
	public MFFInlineDropletFormException(String pStr, Collection<String> pPropertyNames, NameContextElement pExceptionSource) {
		this(pStr, pPropertyNames);
		mExceptionSource = pExceptionSource;
		if (pPropertyNames != null) {
			getPropertyNames().addAll(pPropertyNames);
		}
	}

	/**
	 * @param pStr
	 * @param pPropertyName
	 * @param pMessageCode
	 */
	public MFFInlineDropletFormException(String pStr, String pPropertyName,
			String pMessageCode) {
		super(pStr, pPropertyName, pMessageCode);
		getPropertyNames().add(pPropertyName);
	}
	
	public MFFInlineDropletFormException(String pStr, List<String> pPropertyNames,
			String pMessageCode) {
		this(pStr, (pPropertyNames == null 
				|| pPropertyNames.isEmpty() ? "" : pPropertyNames.iterator().next()), pMessageCode);
		if (pPropertyNames != null) {
			getPropertyNames().addAll(pPropertyNames);
		}
	}
	
	/**
	 * @param pStr
	 * @param pPropertyName
	 * @param pMessageCode
	 */
	public MFFInlineDropletFormException(String pStr, String pPropertyName,
			String pMessageCode, NameContextElement pExceptionSource) {
		this(pStr, pPropertyName, pMessageCode);
		mExceptionSource = pExceptionSource;
	}
	
	public MFFInlineDropletFormException(String pStr, List<String> pPropertyNames,
			String pMessageCode, NameContextElement pExceptionSource) {
		this(pStr, (pPropertyNames == null 
				|| pPropertyNames.isEmpty() ? "" : pPropertyNames.iterator().next()), pMessageCode);
		mExceptionSource = pExceptionSource;
		if (pPropertyNames != null) {
			getPropertyNames().addAll(pPropertyNames);
		}
	}

	
		//------------------------------------------
		// PRIVATE METHODS
		// ------------------------------------------
		
		/**
		 * Return the full component + property name string.  For example if the property
		 * is "value.email" and the component that created the exception was the ProfileFormHandler,
		 * return "/atg/userprofiling/ProfileFormHandler.value.email"
		 * 
		 * @param pPropertyName
		 * @return
		 */
		private String getFullPropertyPath(String pPropertyName) {
			// if someone didn't give us exceptionSource we can't do much
			if (pPropertyName == null) {
				return null;
			}
			
			// if the exception source is null, the property name will be the selector
			if (getExceptionSource() == null) {
			  return pPropertyName;
			}
			
			// if propertyPath starts with a slash, assume someone actually passed a complete path
			if (pPropertyName.startsWith("/")) {
				return pPropertyName;
			}

			String componentName = getRelativeName(getExceptionSource());
			if (componentName == null) {
				return null;
			}
			
			StringBuilder builder = new StringBuilder(componentName);
			if (!pPropertyName.startsWith(".")) {
				builder.append('.');
			}
			builder.append(pPropertyName);
			
			return builder.toString();
		}
		
		//------------------------------------------
		// PROTECTED METHODS
		// ------------------------------------------
		
		/**
		 * Looks up the "config path name" of a given component i.e. stop at request or session scope root.
		 * 
		 * @param pElement
		 * @return
		 */
		protected String getRelativeName(NameContextElement pElement) {
			Stack<String> names = new Stack<String>();
			names.push(pElement.getName());
			if (pElement.getNameContext() != null) {
				collectContextNames(pElement.getNameContext(), names);
			}
			StringBuilder builder = new StringBuilder();
			while (!names.empty()) {
				builder.append('/').append(names.pop());
			}
			return builder.toString();
		}
		
		/**
		 * Recursively collects all name elements up to the root (global, session or request)
		 * 
		 * @param ctx
		 * @param names
		 */
		protected void collectContextNames(NameContext ctx, Stack<String> names) {
			if (!(ctx instanceof SessionNameContext) && ctx.getName() != null && !ctx.getName().startsWith("RequestScope")) {
				names.push(ctx.getName());
				if (ctx.getNameContext() != null) {
					collectContextNames(ctx.getNameContext(), names);
				}
			}
		}
	
		
	//------------------------------------------
	// GETTERS & SETTERS
	// ------------------------------------------
	
	/**
	 * @return the exceptionSource
	 */
	public NameContextElement getExceptionSource() {
		return mExceptionSource;
	}

	/**
	 * @param pExceptionSource the exceptionSource to set
	 */
	public void setExceptionSource(NameContextElement pExceptionSource) {
		mExceptionSource = pExceptionSource;
	}

	public Map<String, String> getExplicitFormElementNames() {
		return mExplicitFormElementNames;
	}

	public Set<String> getPropertyNames() {
		return mPropertyNames;
	}

	public String getFormId() {
		return mFormId;
	}

	public void setFormId(String pFormId) {
		mFormId = pFormId;
	}
	
}
